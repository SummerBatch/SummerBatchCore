//
//   Copyright 2015 Blu Age Corporation - Plano, Texas
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

//   This file has been modified.
//   Original copyright notice :

/*
 * Copyright 2006-2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using Summer.Batch.Core.Launch;
using Summer.Batch.Infrastructure.Item;
using Summer.Batch.Common.Util;
using System;

namespace Summer.Batch.Core.Step.Job
{
    /// <summary>
    /// An <see cref="IStep"/> that delegates to a Job to do its work. This is a
    /// great tool for managing dependencies between jobs, and also to modularise
    /// complex step logic into something that is testable in isolation. The job is
    /// executed with parameters that can be extracted from the step execution, hence
    /// this step can also be usefully used as the worker in a parallel or
    /// partitioned execution.
    /// </summary>
    public class JobStep : AbstractStep
    {
        private const string JobParametersKey = "JobStep.JOB_PARAMETERS";

        /// <summary>
        /// Job property.
        /// </summary>
        public IJob Job { private get; set; }

        /// <summary>
        /// Job launcher property.
        /// </summary>
        public IJobLauncher JobLauncher { private get; set; }
        private IJobParametersExtractor _jobParametersExtractor = new DefaultJobParametersExtractor();

        /// <summary>
        /// The <see cref="IJobParametersExtractor"/>is used to extract
        /// JobParametersExtractor from the <see cref="StepExecution"/>to run the
        /// <see cref="IJob"/>. By default an instance will be provided that simply copies
        /// JobParameters from the parent job.
        /// </summary>
        public IJobParametersExtractor JobParametersExtractor
        {
            set { _jobParametersExtractor = value; }
        }

        /// <summary>
        /// Invoked programmatically by JobStepBuilder.
        /// @see IInitializationPostOperations#AfterPropertiesSet.
        /// </summary>
        /// <exception cref="Exception">&nbsp;</exception>
        public override void AfterPropertiesSet() { 
            base.AfterPropertiesSet();
            Assert.State(JobLauncher != null, "A JobLauncher must be provided");
            Assert.State(Job != null, "A Job must be provided");
        }

        /// <summary>
        /// Custom constructor using a name 
        /// </summary>
        /// <param name="name"></param>
        public JobStep(string name)
            : base(name)
        {
        }

        /// <summary>
        /// Execute the job provided by delegating to the <see cref="IJobLauncher"/>to
        /// prevent duplicate executions. The job parameters will be generated by the
        /// <see cref="IJobParametersExtractor"/>provided (if any), otherwise empty. On a
        /// restart, the job parameters will be the same as the last (failed) execution.
        /// </summary>
        /// <param name="stepExecution"></param>
        protected override void DoExecute(StepExecution stepExecution)
        {
            ExecutionContext executionContext = stepExecution.ExecutionContext;
            executionContext.Put(StepConstants.StepTypeKey, GetType().Name);
            JobParameters jobParameters;
            if (executionContext.ContainsKey(JobParametersKey))
            {
                jobParameters = (JobParameters)executionContext.Get(JobParametersKey);
            }
            else
            {
                jobParameters = _jobParametersExtractor.GetJobParameters(Job, stepExecution);
                executionContext.Put(JobParametersKey, jobParameters);
            }

            JobExecution jobExecution = JobLauncher.Run(Job, jobParameters);
            if (jobExecution.Status.IsUnsuccessful())
            {
                // AbstractStep will take care of the step execution status
                throw new UnexpectedJobExecutionException("Step failure: the delegate Job failed in JobStep.");
            }
        }
    }
}